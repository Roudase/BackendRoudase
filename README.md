# BackendRoudase — Лабораторні роботи 1–4

## Опис проєкту

**BackendRoudase** — це навчальний бекенд‑застосунок для обліку витрат користувачів.
Проєкт реалізовано на **Node.js + TypeScript** з використанням **Express** як HTTP‑фреймворку
та **Prisma ORM** для роботи з базою даних **PostgreSQL**.

У цій версії проєкту реалізовано вимоги **лабораторних робіт 1–4** дисципліни
«Технології серверного програмного забезпечення»:

- ЛР1 — базовий HTTP‑сервер та ендпоінт `/healthcheck`.
- ЛР2 — CRUD‑функціонал для користувачів, категорій витрат та записів витрат.
- ЛР3 — **валідація вхідних даних, обробка помилок та робота з ORM (Prisma + PostgreSQL)**
  з реалізацією додаткового завдання згідно варіанту.
- ЛР4 — **автентифікація користувачів за допомогою JWT**, захист ендпоінтів та інтеграція з уже реалізованим функціоналом обліку витрат.

---

## Варіант лабораторної

Номер групи: **34**  
Обчислення варіанту: `34 mod 3 = 1` → варіант **«Валюти»**.

Згідно з методичними вказівками, варіант з остачею **1** відповідає функціоналу **валют**:

- Додано окрему сутність **Currency** з унікальним кодом (`code`, наприклад `"USD"`) та назвою (`name`).  
- Для кожного користувача може бути задана **валюта за замовчуванням** (`defaultCurrencyId`).  
- Під час створення витрати:
  - **можна** явно вказати `currencyId`;
  - якщо `currencyId` **не вказано**, використовується валюта за замовчуванням користувача;
  - якщо в користувача **немає** валюти за замовчуванням і `currencyId` не передано — повертається помилка валідації.

Таким чином, вимоги варіанта «Валюти» повністю реалізовано в межах поточного проєкту.

---

## Технологічний стек

- **Node.js** + **TypeScript**
- **Express** — HTTP‑фреймворк
- **Prisma ORM** — робота з PostgreSQL
- **PostgreSQL** — СУБД
- **Docker** та **docker-compose** — для локального підняття БД та застосунку
- **Postman** — для тестування REST‑ендпоінтів

---

## Структура проєкту

```text
BackendRoudase/
├── prisma/
│   ├── schema.prisma        # Опис ORM‑моделей (User, Category, Currency, Record)
│   └── migrations/          # Міграції для створення таблиць у БД
├── src/
│   ├── app.ts               # Ініціалізація Express‑додатку, middleware, обробка помилок
│   ├── db.ts                # Ініціалізація PrismaClient
│   └── routes.ts            # Визначення REST‑ендпоінтів
├── Dockerfile               # Prod‑збірка Node.js‑застосунку
├── docker-compose.yml       # Контейнери для app + db (PostgreSQL)
├── package.json             # Скрипти npm та залежності
├── tsconfig.json            # Налаштування TypeScript
└── README.md                # Поточний файл опису
```

---

## Налаштування та запуск

### 1. Змінні середовища

Для роботи Prisma та PostgreSQL необхідна змінна середовища `DATABASE_URL` у форматі:

```env
DATABASE_URL="postgresql://<user>:<password>@<host>:<port>/<database>?schema=public"
```

Приклади:

- **Локально (без Docker):**
  ```env
  DATABASE_URL="postgresql://postgres:postgres@localhost:5432/backend_roudase"
  ```
- **Через docker-compose (контейнер `db`):**
  ```env
  DATABASE_URL="postgresql://postgres:postgres@db:5432/backend_roudase"
  ```

Файл `.env` можна створити в корені проєкту; Prisma автоматично його зчитує.

---

### 2. Локальний запуск (без Docker)

1. Встановити залежності:
   ```bash
   npm install
   ```

2. Підняти локальну базу даних PostgreSQL (будь‑яким зручним способом) і встановити `DATABASE_URL`.

3. Виконати міграції та згенерувати Prisma‑клієнт:
   ```bash
   npx prisma migrate dev
   npx prisma generate
   ```

4. Запуск у режимі розробки:
   ```bash
   npm run dev
   ```

   За замовчуванням застосунок слухає порт **8080** (можна змінити через `PORT`).

5. Продакшн‑збірка та запуск:
   ```bash
   npm run build
   npm start
   ```

---

### 3. Запуск через Docker Compose

1. Переконатися, що Docker та docker-compose встановлено.
2. У корені проєкту виконати:
   ```bash
   docker compose up --build
   ```
3. Контейнери:
   - `db` — PostgreSQL
   - `app` — Node.js бекенд

Застосунок буде доступний за адресою:  
`http://localhost:8080`

---

## ORM‑моделі (Prisma)

Основні сутності, описані у `prisma/schema.prisma`:

- **User**
  - `id` — первинний ключ
  - `name` — ім’я користувача
  - `email` — унікальна адреса електронної пошти (використовується для логіну)
  - `passwordHash` — хеш пароля користувача (зберігається лише в БД, не повертається в API)
  - `defaultCurrencyId` — (опційно) посилання на валюту за замовчуванням

- **Category**
  - `id`
  - `name` — назва категорії витрат

- **Currency**
  - `id`
  - `code` — унікальний код валюти (наприклад, `"USD"`)
  - `name` — назва валюти
  - зв’язок з користувачами як валюта за замовчуванням

- **Record**
  - `id`
  - `userId` — посилання на користувача
  - `categoryId` — посилання на категорію витрат
  - `currencyId` — посилання на валюту
  - `amount` — сума витрати
  - `createdAt` — дата створення

---

## Огляд REST‑API

Базова адреса: `http://localhost:8080` (або `{{baseUrl}}` у Postman).

Починаючи з **лабораторної роботи 4**, більшість ендпоінтів захищені за допомогою JWT‑токена:

- публічні ендпоінти: `GET /healthcheck`, `POST /user` (реєстрація), `POST /auth/login` (логін);
- усі інші запити повинні містити заголовок `Authorization: Bearer <token>`.

### 1. Healthcheck

- `GET /healthcheck`  
  Повертає поточну дату та статус сервера.

Приклад відповіді:
```json
{
  "date": "2025-12-09T21:15:00.000Z",
  "status": "ok"
}
```

---

### 2. Користувачі (User)

#### Реєстрація користувача

- `POST /user`
- Body (JSON):
  ```json
  {
    "name": "Test User",
    "email": "test@example.com",
    "password": "secret123"
  }
  ```
  Повертає створеного користувача без поля `passwordHash`.

#### Логін користувача (отримання JWT‑токена)

- `POST /auth/login`
- Body (JSON):
  ```json
  {
    "email": "test@example.com",
    "password": "secret123"
  }
  ```
  У відповіді повертається обʼєкт із полем `accessToken`, яке використовується в заголовку `Authorization: Bearer <token>`.

#### Отримати користувача за `id`

- `GET /user/:userId`

#### Отримати список користувачів

- `GET /users`  
  Повертає список користувачів з інформацією про валюту за замовчуванням.

#### Встановити валюту за замовчуванням для користувача

- `PATCH /user/:userId/currency`
- Body (JSON):
  ```json
  {
    "currencyId": 1
  }
  ```

#### Видалити користувача

- `DELETE /user/:userId`

---

### 3. Валюти (Currency)

#### Список валют

- `GET /currency`

#### Створити валюту

- `POST /currency`
- Body (JSON):
  ```json
  {
    "code": "USD",
    "name": "US Dollar"
  }
  ```

#### Видалити валюту

- `DELETE /currency/:id`

---

### 4. Категорії витрат (Category)

#### Список категорій

- `GET /category`

#### Створити категорію

- `POST /category`
- Body (JSON):
  ```json
  {
    "name": "Food"
  }
  ```

#### Видалити категорію

- `DELETE /category?id=1`

---

### 5. Записи витрат (Record)

#### Створити запис витрати

- `POST /record`
- Body (JSON):
  ```json
  {
    "userId": 1,
    "categoryId": 1,
    "amount": 100.5,
    "currencyId": 1
  }
  ```

  Поле `currencyId` **опційне**:
  - якщо вказано — використовується ця валюта;
  - якщо не вказано — використовується валюта за замовчуванням користувача;
  - якщо валюти за замовчуванням немає — повертається помилка.

#### Отримати запис за `id`

- `GET /record/:recordId`

#### Отримати список записів (з фільтрами)

- `GET /record`
  - Опційні query‑параметри:
    - `userId` — фільтр за користувачем
    - `categoryId` — фільтр за категорією
  - Приклад: `/record?userId=1&categoryId=2`

#### Видалити запис

- `DELETE /record/:recordId`

---

## Валідація та обробка помилок

Усі основні ендпоінти містять **перевірку вхідних даних**:

- Перевірка типів (`name` — не порожній рядок, `amount` — число, `userId` / `categoryId` / `currencyId` — цілі числа).
- Перевірка існування пов’язаних сутностей (користувача, категорії, валюти).
- Для некоректних запитів повертається статус **400** з JSON‑повідомленням про помилку.
- Для неіснуючих ресурсів — статус **404**.

На рівні `app.ts` реалізовано **централізований обробник помилок**, який перехоплює
неочікувані виключення та повертає статус **500** з уніфікованою JSON‑відповіддю.

---

## Postman‑колекції

Для зручного тестування API додано кілька Postman‑колекцій:

- `BackendRoudase-lab3.postman_collection.json` — базові ендпоінти для ЛР1–3 (healthcheck, користувачі, валюти, категорії, записи).
- `BackendRoudase-lab4.postman_collection.json` — ті самі ендпоінти з налаштованим флоу **реєстрація → логін → робота з захищеними JWT‑маршрутами** (ЛР4).

Також додано середовища (environment files):

- `BackendRoudase-local.postman_environment.json` — для локального запуску (`baseUrl = http://localhost:8080`).
- `BackendRoudase-render.postman_environment.json` — для продакшен‑деплою на Render.

### Як імпортувати

1. Відкрити **Postman** → `Import` → `File`.
2. Обрати потрібну колекцію (`BackendRoudase-lab3.postman_collection.json` або `BackendRoudase-lab4.postman_collection.json`).
3. За бажанням імпортувати відповідний environment‑файл та активувати його.
4. Переконатися, що змінна `baseUrl` в середовищі вказує на:
   - `http://localhost:8080` — для локальної розробки;
   - або URL сервісу на **Render**.

У колекції для ЛР4 токен аутентифікації автоматично зберігається у змінну `token`
на рівні колекції після успішного запиту `POST /auth/login` і далі використовується
в заголовку `Authorization: Bearer {{token}}` для захищених ендпоінтів.

---

## Git та теги

Для маркування версій згідно методичних рекомендацій можна використовувати теги:

```bash
git tag v3.0.0 -a -m "Lab 3"
git tag v4.0.0 -a -m "Lab 4 (JWT auth)"
git push --tags
```

Де:
- `v3.0.0` — версія застосунку, що відповідає реалізації лабораторної роботи 3;
- `v4.0.0` — версія із доданою аутентифікацією користувачів (JWT) згідно лабораторної роботи 4.

### Postman Flows

**2 лабораторна робота:**

![Lab 2 flow](assets/lab2-flow.png)

**4 лабораторна робота:**

![Lab 4 flow](assets/lab4-flow.png)